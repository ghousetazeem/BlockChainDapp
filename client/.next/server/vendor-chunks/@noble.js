"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/secp256k1/lib/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/secp256k1/lib/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signSync: () => (/* binding */ signSync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\n\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\n\nconst vopts = { strict: true };\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nconst schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUI7QUFDakI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Nyb3dkZnVuZGluZy1kYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9zZWNwMjU2azEvbGliL2VzbS9pbmRleC5qcz9jODJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCAqIGFzIG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmNvbnN0IF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IENVUlZFID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufSk7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuY29uc3QgZW5kbyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIHNwbGl0U2NhbGFyKGspIHtcbiAgICAgICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgIH0sXG59O1xuY29uc3QgZmllbGRMZW4gPSAzMjtcbmNvbnN0IGdyb3VwTGVuID0gMzI7XG5jb25zdCBoYXNoTGVuID0gMzI7XG5jb25zdCBjb21wcmVzc2VkTGVuID0gZmllbGRMZW4gKyAxO1xuY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIGZpZWxkTGVuICsgMTtcbmV4cG9ydCB7IENVUlZFIH07XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyh4KSB7XG4gICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICBjb25zdCB4MiA9IG1vZCh4ICogeCk7XG4gICAgY29uc3QgeDMgPSBtb2QoeDIgKiB4KTtcbiAgICByZXR1cm4gbW9kKHgzICsgYSAqIHggKyBiKTtcbn1cbmNvbnN0IFVTRV9FTkRPTU9SUEhJU00gPSBDVVJWRS5hID09PSBfMG47XG5jbGFzcyBTaGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEphY1BvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBKYWNvYmlhblBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xufVxuY2xhc3MgSmFjb2JpYW5Qb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0phY29iaWFuUG9pbnQjZnJvbUFmZmluZTogZXhwZWN0ZWQgUG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5lcXVhbHMoUG9pbnQuWkVSTykpXG4gICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQocC54LCBwLnksIF8xbik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FmZmluZUJhdGNoKHBvaW50cykge1xuICAgICAgICBjb25zdCB0b0ludiA9IGludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAueikpO1xuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQudG9BZmZpbmVCYXRjaChwb2ludHMpLm1hcChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0SmFjUG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgcmV0dXJuIFUxID09PSBVMiAmJiBTMSA9PT0gUzI7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpLCB0aGlzLnopO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IHgxYiA9IFgxICsgQjtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKHgxYiAqIHgxYikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiBFKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEphY1BvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIgfSA9IG90aGVyO1xuICAgICAgICBpZiAoWDIgPT09IF8wbiB8fCBZMiA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChYMSA9PT0gXzBuIHx8IFkxID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgSCA9IG1vZChVMiAtIFUxKTtcbiAgICAgICAgY29uc3QgciA9IG1vZChTMiAtIFMxKTtcbiAgICAgICAgaWYgKEggPT09IF8wbikge1xuICAgICAgICAgICAgaWYgKHIgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBISCA9IG1vZChIICogSCk7XG4gICAgICAgIGNvbnN0IEhISCA9IG1vZChIICogSEgpO1xuICAgICAgICBjb25zdCBWID0gbW9kKFUxICogSEgpO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChyICogciAtIEhISCAtIF8ybiAqIFYpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChyICogKFYgLSBYMykgLSBTMSAqIEhISCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKFoxICogWjIgKiBIKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgUDAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGFyID09PSAnYmlnaW50JyAmJiBzY2FsYXIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBQMDtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIVVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGxldCBwID0gUDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgIGxldCBrMXAgPSBQMDtcbiAgICAgICAgbGV0IGsycCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIGVuZG8uYmV0YSksIGsycC55LCBrMnAueik7XG4gICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgfVxuICAgIHByZWNvbXB1dGVXaW5kb3coVykge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgKyAxIDogMjU2IC8gVyArIDE7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgd05BRihuLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBpZiAoIWFmZmluZVBvaW50ICYmIHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuQkFTRSkpXG4gICAgICAgICAgICBhZmZpbmVQb2ludCA9IFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFcgPSAoYWZmaW5lUG9pbnQgJiYgYWZmaW5lUG9pbnQuX1dJTkRPV19TSVpFKSB8fCAxO1xuICAgICAgICBpZiAoMjU2ICUgVykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCN3TkFGOiBJbnZhbGlkIHByZWNvbXB1dGF0aW9uIHdpbmRvdywgbXVzdCBiZSBwb3dlciBvZiAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNvbXB1dGVzID0gYWZmaW5lUG9pbnQgJiYgcG9pbnRQcmVjb21wdXRlcy5nZXQoYWZmaW5lUG9pbnQpO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVzKSB7XG4gICAgICAgICAgICBwcmVjb21wdXRlcyA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhXKTtcbiAgICAgICAgICAgIGlmIChhZmZpbmVQb2ludCAmJiBXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVoocHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KGFmZmluZVBvaW50LCBwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGxldCBmID0gSmFjb2JpYW5Qb2ludC5CQVNFO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIChVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyA6IDI1NiAvIFcpO1xuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxO1xuICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhciwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICBsZXQgZmFrZTtcbiAgICAgICAgaWYgKFVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBrMXAgPSBjb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICBrMnAgPSBjb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBlbmRvLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52Wikge1xuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTyk7XG4gICAgICAgIGlmIChpbnZaID09IG51bGwpXG4gICAgICAgICAgICBpbnZaID0gaXMwID8gXzhuIDogaW52ZXJ0KHopO1xuICAgICAgICBjb25zdCBpejEgPSBpbnZaO1xuICAgICAgICBjb25zdCBpejIgPSBtb2QoaXoxICogaXoxKTtcbiAgICAgICAgY29uc3QgaXozID0gbW9kKGl6MiAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGF4ID0gbW9kKHggKiBpejIpO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaXozKTtcbiAgICAgICAgY29uc3QgenogPSBtb2QoeiAqIGl6MSk7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbn1cbkphY29iaWFuUG9pbnQuQkFTRSA9IG5ldyBKYWNvYmlhblBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuKTtcbkphY29iaWFuUG9pbnQuWkVSTyA9IG5ldyBKYWNvYmlhblBvaW50KF8wbiwgXzFuLCBfMG4pO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICUgXzJuID09PSBfMG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBsZXQgeSA9IHNxcnRNb2QoeTIpO1xuICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgaWYgKGlzU2hvcnQpIHtcbiAgICAgICAgICAgIGlmIChpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0Qnl0ZU9kZCA9IChieXRlc1swXSAmIDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMSwgZmllbGRMZW4gKyAxKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KGZpZWxkTGVuICsgMSwgZmllbGRMZW4gKiAyICsgMSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSBmaWVsZExlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlcjogaW52YWxpZCByZWNvdmVyeSBiaXQnKTtcbiAgICAgICAgY29uc3QgaCA9IHRydW5jYXRlSGFzaChlbnN1cmVCeXRlcyhtc2dIYXNoKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJhZGogPSByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMyA/IHIgKyBuIDogcjtcbiAgICAgICAgY29uc3QgcmludiA9IGludmVydChyYWRqLCBuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoLWggKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2QocyAqIHJpbnYsIG4pO1xuICAgICAgICBjb25zdCBwcmVmaXggPSByZWNvdmVyeSAmIDEgPyAnMDMnIDogJzAyJztcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG8zMmJTdHIocmFkaikpO1xuICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpO1xuICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWNvdmVyIHNpZ25hdHVyZTogcG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvSGV4KGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB4ID0gbnVtVG8zMmJTdHIodGhpcy54KTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNFdmVuWSgpID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7eH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAwNCR7eH0ke251bVRvMzJiU3RyKHRoaXMueSl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0hleFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KHRydWUpLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0b1Jhd1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnUG9pbnQgaXMgbm90IG9uIGVsbGlwdGljIGN1cnZlJztcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkgfHwgIWlzVmFsaWRGaWVsZEVsZW1lbnQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IG1vZCh5ICogeSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3MoeCk7XG4gICAgICAgIGlmIChtb2QobGVmdCAtIHJpZ2h0KSAhPT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmRvdWJsZSgpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmFkZChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUob3RoZXIpKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5tdWx0aXBseShzY2FsYXIsIHRoaXMpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgUCA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKTtcbiAgICAgICAgY29uc3QgYVAgPSBhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8IHRoaXMgIT09IFBvaW50LkJBU0UgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKTtcbiAgICAgICAgY29uc3QgYlEgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUoUSkubXVsdGlwbHlVbnNhZmUoYik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGFQLmFkZChiUSk7XG4gICAgICAgIHJldHVybiBzdW0uZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTykgPyB1bmRlZmluZWQgOiBzdW0udG9BZmZpbmUoKTtcbiAgICB9XG59XG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSk7XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzBuKTtcbmZ1bmN0aW9uIHNsaWNlREVSKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSA+PSA4ID8gJzAwJyArIHMgOiBzO1xufVxuZnVuY3Rpb24gcGFyc2VERVJJbnQoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGhgKTtcbiAgICB9XG4gICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiByZXNbMV0gPD0gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHRyYWlsaW5nIGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBieXRlc1RvTnVtYmVyKHJlcyksIGxlZnQ6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlREVSU2lnbmF0dXJlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT0gMHgzMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBpZiAoZGF0YVsxXSAhPT0gZGF0YS5sZW5ndGggLSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhOiByLCBsZWZ0OiBzQnl0ZXMgfSA9IHBhcnNlREVSSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgIGNvbnN0IHsgZGF0YTogcywgbGVmdDogckJ5dGVzTGVmdCB9ID0gcGFyc2VERVJJbnQoc0J5dGVzKTtcbiAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nOiAke2J5dGVzVG9IZXgockJ5dGVzTGVmdCl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnU2lnbmF0dXJlLmZyb21Db21wYWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9OiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCBzdHIgPSBhcnIgPyBieXRlc1RvSGV4KGhleCkgOiBoZXg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIDY0LWJ5dGUgaGV4YCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGhleFRvTnVtYmVyKHN0ci5zbGljZSgwLCA2NCkpLCBoZXhUb051bWJlcihzdHIuc2xpY2UoNjQsIDEyOCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2lnbmF0dXJlLmZyb21ERVI6IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gcGFyc2VERVJTaWduYXR1cmUoYXJyID8gaGV4IDogaGV4VG9CeXRlcyhoZXgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tREVSKGhleCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogciBtdXN0IGJlIDAgPCByIDwgbicpO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHMgbXVzdCBiZSAwIDwgcyA8IG4nKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRS5uID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucyA+IEhBTEY7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kKC10aGlzLnMsIENVUlZFLm4pKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHNIZXhMID0gc0hleC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBySGV4TCA9IHJIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleEwpO1xuICAgICAgICBjb25zdCByTGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4TCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwgKyBzSGV4TCArIDQpO1xuICAgICAgICByZXR1cm4gYDMwJHtsZW5ndGh9MDIke3JMZW59JHtySGV4fTAyJHtzTGVufSR7c0hleH1gO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUlJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUkhleCgpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChiKSA9PiBiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuZnVuY3Rpb24gbnVtVG8zMmJTdHIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJpZ2ludCcpO1xuICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgUE9XXzJfMjU2KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXIgMCA8PSBuIDwgMl4yNTYnKTtcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbmZ1bmN0aW9uIG51bVRvMzJiKG51bSkge1xuICAgIGNvbnN0IGIgPSBoZXhUb0J5dGVzKG51bVRvMzJiU3RyKG51bSkpO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IGV4cGVjdGVkIDMyIGJ5dGVzJyk7XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvTnVtYmVyOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW0pO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIHNjYWxhcjogMCA8IHNjYWxhciA8IGN1cnZlLm4nKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3FydE1vZCh4KSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCBfNm4gPSBCaWdJbnQoNik7XG4gICAgY29uc3QgXzExbiA9IEJpZ0ludCgxMSk7XG4gICAgY29uc3QgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyk7XG4gICAgY29uc3QgXzQ0biA9IEJpZ0ludCg0NCk7XG4gICAgY29uc3QgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeCAqIHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHgpICUgUDtcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybikgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4bikgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82bikgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJ0ID0gcG93Mih0MiwgXzJuKTtcbiAgICBjb25zdCB4YyA9IChydCAqIHJ0KSAlIFA7XG4gICAgaWYgKHhjICE9PSB4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJ0O1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHNjcmF0Y2ggPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBfMW4pO1xuICAgIGNvbnN0IGludmVydGVkID0gaW52ZXJ0KGxhc3RNdWx0aXBsaWVkLCBwKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gbW9kKGFjYyAqIHNjcmF0Y2hbaV0sIHApO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiBzY3JhdGNoO1xufVxuZnVuY3Rpb24gYml0czJpbnRfMihieXRlcykge1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIGdyb3VwTGVuICogODtcbiAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiB0cnVuY2F0ZUhhc2goaGFzaCwgdHJ1bmNhdGVPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBoID0gYml0czJpbnRfMihoYXNoKTtcbiAgICBpZiAodHJ1bmNhdGVPbmx5KVxuICAgICAgICByZXR1cm4gaDtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIHJldHVybiBoID49IG4gPyBoIC0gbiA6IGg7XG59XG5sZXQgX3NoYTI1NlN5bmM7XG5sZXQgX2htYWNTaGEyNTZTeW5jO1xuY2xhc3MgSG1hY0RyYmcge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hMZW4sIHFCeXRlTGVuKSB7XG4gICAgICAgIHRoaXMuaGFzaExlbiA9IGhhc2hMZW47XG4gICAgICAgIHRoaXMucUJ5dGVMZW4gPSBxQnl0ZUxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDEpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDApO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBobWFjKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gdXRpbHMuaG1hY1NoYTI1Nih0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGhtYWNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gX2htYWNTaGEyNTZTeW5jKHRoaXMuaywgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgY2hlY2tTeW5jKCkge1xuICAgICAgICBpZiAodHlwZW9mIF9obWFjU2hhMjU2U3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGFFcnJvcignaG1hY1NoYTI1NlN5bmMgbmVlZHMgdG8gYmUgc2V0Jyk7XG4gICAgfVxuICAgIGluY3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgMSwwMDAgayB2YWx1ZXMgZm9yIHNpZ24oKSwgYWxsIHdlcmUgaW52YWxpZCcpO1xuICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZWVkKHNlZWQgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAxXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICB9XG4gICAgcmVzZWVkU3luYyhzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmhtYWNTeW5jKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAwXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbmNyKCk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHRoaXMucUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHRoaXMudi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHRoaXMudi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5QO1xufVxuZnVuY3Rpb24ga21kVG9TaWcoa0J5dGVzLCBtLCBkLCBsb3dTID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgayA9IHRydW5jYXRlSGFzaChrQnl0ZXMsIHRydWUpO1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qga2ludiA9IGludmVydChrLCBuKTtcbiAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKTtcbiAgICBjb25zdCByID0gbW9kKHEueCwgbik7XG4gICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBtb2Qoa2ludiAqIG1vZChtICsgZCAqIHIsIG4pLCBuKTtcbiAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gc2lnLnIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICBpZiAobG93UyAmJiBzaWcuaGFzSGlnaFMoKSkge1xuICAgICAgICBzaWcgPSBzaWcubm9ybWFsaXplUygpO1xuICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWcsIHJlY292ZXJ5IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgIGxldCBudW07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIG51bSA9IGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoa2V5KSAmJiBrZXkgPiAwKSB7XG4gICAgICAgIG51bSA9IEJpZ0ludChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMiAqIGdyb3VwTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIGtleScpO1xuICAgICAgICBudW0gPSBoZXhUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gYnl0ZXNUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcml2YXRlIGtleTogMCA8IGtleSA8IG4nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICBwdWJsaWNLZXkuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgc2lnbmF0dXJlLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICBpZiAoc3RyKVxuICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuICogMiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbiAqIDI7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXRTaGFyZWRTZWNyZXQ6IHNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgYiA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNCKTtcbiAgICBiLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBieXRlcy5sZW5ndGggPiBmaWVsZExlbiA/IGJ5dGVzLnNsaWNlKDAsIGZpZWxkTGVuKSA6IGJ5dGVzO1xuICAgIHJldHVybiBieXRlc1RvTnVtYmVyKHNsaWNlKTtcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzKGJ5dGVzKSB7XG4gICAgY29uc3QgejEgPSBiaXRzMmludChieXRlcyk7XG4gICAgY29uc3QgejIgPSBtb2QoejEsIENVUlZFLm4pO1xuICAgIHJldHVybiBpbnQyb2N0ZXRzKHoyIDwgXzBuID8gejEgOiB6Mik7XG59XG5mdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgIHJldHVybiBudW1UbzMyYihudW0pO1xufVxuZnVuY3Rpb24gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5KSB7XG4gICAgaWYgKG1zZ0hhc2ggPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2gsIG5vdCBcIiR7bXNnSGFzaH1cImApO1xuICAgIGNvbnN0IGgxID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgZCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgYml0czJvY3RldHMoaDEpXTtcbiAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dHJhRW50cm9weSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGV4dHJhRW50cm9weSA9IHV0aWxzLnJhbmRvbUJ5dGVzKGZpZWxkTGVuKTtcbiAgICAgICAgY29uc3QgZSA9IGVuc3VyZUJ5dGVzKGV4dHJhRW50cm9weSk7XG4gICAgICAgIGlmIChlLmxlbmd0aCAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ246IEV4cGVjdGVkICR7ZmllbGRMZW59IGJ5dGVzIG9mIGV4dHJhIGRhdGFgKTtcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTtcbiAgICBjb25zdCBtID0gYml0czJpbnQoaDEpO1xuICAgIHJldHVybiB7IHNlZWQsIG0sIGQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2lnKHJlY1NpZywgb3B0cykge1xuICAgIGNvbnN0IHsgc2lnLCByZWNvdmVyeSB9ID0gcmVjU2lnO1xuICAgIGNvbnN0IHsgZGVyLCByZWNvdmVyZWQgfSA9IE9iamVjdC5hc3NpZ24oeyBjYW5vbmljYWw6IHRydWUsIGRlcjogdHJ1ZSB9LCBvcHRzKTtcbiAgICBjb25zdCBoYXNoZWQgPSBkZXIgPyBzaWcudG9ERVJSYXdCeXRlcygpIDogc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHJlY292ZXJlZCA/IFtoYXNoZWQsIHJlY292ZXJ5XSA6IGhhc2hlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgY29uc3QgZHJiZyA9IG5ldyBIbWFjRHJiZyhoYXNoTGVuLCBncm91cExlbik7XG4gICAgYXdhaXQgZHJiZy5yZXNlZWQoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhhd2FpdCBkcmJnLmdlbmVyYXRlKCksIG0sIGQsIG9wdHMuY2Fub25pY2FsKSkpXG4gICAgICAgIGF3YWl0IGRyYmcucmVzZWVkKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhkcmJnLmdlbmVyYXRlU3luYygpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydCB7IHNpZ24sIHNpZ25TeW5jIH07XG5jb25zdCB2b3B0cyA9IHsgc3RyaWN0OiB0cnVlIH07XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gdm9wdHMpIHtcbiAgICBsZXQgc2lnO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZyA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIGlmIChvcHRzLnN0cmljdCAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2gobXNnSGFzaCk7XG4gICAgbGV0IFA7XG4gICAgdHJ5IHtcbiAgICAgICAgUCA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHNpbnYgPSBpbnZlcnQocywgbik7XG4gICAgY29uc3QgdTEgPSBtb2QoaCAqIHNpbnYsIG4pO1xuICAgIGNvbnN0IHUyID0gbW9kKHIgKiBzaW52LCBuKTtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpO1xuICAgIGlmICghUilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHYgPSBtb2QoUi54LCBuKTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSB1dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzaWduOiBFeHBlY3RlZCB2YWxpZCBtZXNzYWdlLCBub3QgXCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgdGhpcy5tID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgeCwgc2NhbGFyIH0gPSB0aGlzLmdldFNjYWxhcihub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgdGhpcy5weCA9IHg7XG4gICAgICAgIHRoaXMuZCA9IHNjYWxhcjtcbiAgICAgICAgdGhpcy5yYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGF1eCByYW5kb21uZXNzJyk7XG4gICAgfVxuICAgIGdldFNjYWxhcihwcml2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdik7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHBvaW50Lmhhc0V2ZW5ZKCkgPyBwcml2IDogQ1VSVkUubiAtIHByaXY7XG4gICAgICAgIHJldHVybiB7IHBvaW50LCBzY2FsYXIsIHg6IHBvaW50LnRvUmF3WCgpIH07XG4gICAgfVxuICAgIGluaXROb25jZShkLCB0MGgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyKHQwaCkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZU5vbmNlKGswaCkge1xuICAgICAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgICAgICBpZiAoazAgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogQ3JlYXRpb24gb2Ygc2lnbmF0dXJlIGZhaWxlZC4gayBpcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQ6IFIsIHg6IHJ4LCBzY2FsYXI6IGsgfSA9IHRoaXMuZ2V0U2NhbGFyKGswKTtcbiAgICAgICAgcmV0dXJuIHsgUiwgcngsIGsgfTtcbiAgICB9XG4gICAgZmluYWxpemVTaWcoUiwgaywgZSwgZCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUoUi54LCBtb2QoayArIGUgKiBkLCBDVVJWRS5uKSkudG9SYXdCeXRlcygpO1xuICAgIH1cbiAgICBlcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgYXdhaXQgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZShhd2FpdCB0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIShhd2FpdCBzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgY2FsY1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB1dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnlTeW5jKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTaGFFcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSB7XG4gICAgU2lnbmF0dXJlOiBTY2hub3JyU2lnbmF0dXJlLFxuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgc2lnblN5bmM6IHNjaG5vcnJTaWduU3luYyxcbiAgICB2ZXJpZnlTeW5jOiBzY2hub3JyVmVyaWZ5U3luYyxcbn07XG5Qb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IFRBR1MgPSB7XG4gICAgY2hhbGxlbmdlOiAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgIGF1eDogJ0JJUDAzNDAvYXV4JyxcbiAgICBub25jZTogJ0JJUDAzNDAvbm9uY2UnLFxufTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbiA9IGdyb3VwTGVuICsgODtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoIDwgbWluTGVuIHx8IGhhc2gubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODZgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBtb2QoYnl0ZXNUb051bWJlcihoYXNoKSwgQ1VSVkUubiAtIF8xbikgKyBfMW47XG4gICAgICAgIHJldHVybiBudW1UbzMyYihudW0pO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB1dGlscy5oYXNoVG9Qcml2YXRlS2V5KHV0aWxzLnJhbmRvbUJ5dGVzKGdyb3VwTGVuICsgOCkpLFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBwb2ludCA9PT0gUG9pbnQuQkFTRSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfM24pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG4gICAgc2hhMjU2OiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTI1NiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG1hY1NoYTI1NjogYXN5bmMgKGtleSwgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNrZXkgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb25jYXRCeXRlcyguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5zaWduKCdITUFDJywgY2tleSwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIbWFjIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4gaGFzaC51cGRhdGUobSkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgaG1hYy1zaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICBobWFjU2hhMjU2U3luYzogdW5kZWZpbmVkLFxuICAgIHRhZ2dlZEhhc2g6IGFzeW5jICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGF3YWl0IHV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHRhZ2dlZEhhc2hTeW5jOiAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdzaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IF9zaGEyNTZTeW5jKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2hhMjU2U3luYyh0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICBfSmFjb2JpYW5Qb2ludDogSmFjb2JpYW5Qb2ludCxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh1dGlscywge1xuICAgIHNoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaGEyNTZTeW5jO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV9zaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9zaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgaG1hY1NoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfaG1hY1NoYTI1NlN5bmMpXG4gICAgICAgICAgICAgICAgX2htYWNTaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/secp256k1/lib/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@noble/secp256k1/lib/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/secp256k1/lib/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURVE: () => (/* binding */ CURVE),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   signSync: () => (/* binding */ signSync),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ \nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: _1n,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\")\n});\nconst divNearest = (a, b)=>(a + b / _2n) / b;\nconst endo = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar (k) {\n        const { n } = CURVE;\n        const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n        const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n        const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n        const b2 = a1;\n        const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\");\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error(\"splitScalarEndo: Endomorphism failed, k=\" + k);\n        }\n        return {\n            k1neg,\n            k1,\n            k2neg,\n            k2\n        };\n    }\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\n\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint)) throw new TypeError(\"JacobianPoint expected\");\n}\nclass JacobianPoint {\n    constructor(x, y, z){\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError(\"JacobianPoint#fromAffine: expected Point\");\n        }\n        if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p)=>p.z));\n        return points.map((p, i)=>p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n) return this;\n        if (X1 === _0n || Y1 === _0n) return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            } else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === \"bigint\" && scalar === _0n) return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n) return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while(k1 > _0n || k2 > _0n){\n            if (k1 & _1n) k1p = k1p.add(d);\n            if (k2 & _1n) k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg) k1p = k1p.negate();\n        if (k2neg) k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            for(let i = 1; i < 2 ** (W - 1); i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;\n        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n        if (256 % W) {\n            throw new Error(\"Point#wNAF: Invalid precomputation window, must be power of 2\");\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for(let window = 0; window < windows; window++){\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            } else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return {\n            p,\n            f\n        };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        } else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([\n            point,\n            fake\n        ])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null) invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0) return Point.ZERO;\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x)) throw new Error(\"Point is not on curve\");\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd) y = mod(-y);\n        } else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd) y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen) return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![\n            0,\n            1,\n            2,\n            3\n        ].includes(recovery)) throw new Error(\"Cannot recover: invalid recovery bit\");\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? \"03\" : \"02\";\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q) throw new Error(\"Cannot recover signature: point at infinify\");\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? \"02\" : \"03\";\n            return `${prefix}${x}`;\n        } else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = \"Point is not on elliptic curve\";\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n) throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? \"00\" + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error(\"Invalid signature integer: trailing length\");\n    }\n    return {\n        data: bytesToNumber(res),\n        left: data.subarray(len + 2)\n    };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error(\"Invalid signature: incorrect length\");\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return {\n        r,\n        s\n    };\n}\nclass Signature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = \"Signature.fromCompact\";\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== \"string\" && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r)) throw new Error(\"Invalid Signature: r must be 0 < r < n\");\n        if (!isWithinCurveOrder(s)) throw new Error(\"Invalid Signature: s must be 0 < s < n\");\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b)=>b instanceof Uint8Array)) throw new Error(\"Uint8Array list expected\");\n    if (arrays.length === 1) return arrays[0];\n    const length = arrays.reduce((a, arr)=>a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({\n    length: 256\n}, (v, i)=>i.toString(16).padStart(2, \"0\"));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array)) throw new Error(\"Expected Uint8Array\");\n    let hex = \"\";\n    for(let i = 0; i < uint8a.length; i++){\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt(\"0x10000000000000000000000000000000000000000000000000000000000000000\");\nfunction numTo32bStr(num) {\n    if (typeof num !== \"bigint\") throw new Error(\"Expected bigint\");\n    if (!(_0n <= num && num < POW_2_256)) throw new Error(\"Expected number 0 <= n < 2^256\");\n    return num.toString(16).padStart(64, \"0\");\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32) throw new Error(\"Error: expected 32 bytes\");\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToNumber: expected string, got \" + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== \"string\") {\n        throw new TypeError(\"hexToBytes: expected string, got \" + typeof hex);\n    }\n    if (hex.length % 2) throw new Error(\"hexToBytes: received invalid unpadded hex\" + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for(let i = 0; i < array.length; i++){\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0) throw new Error(\"Invalid byte sequence\");\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === \"number\" && Number.isSafeInteger(num) && num > 0) return BigInt(num);\n    if (typeof num === \"bigint\" && isWithinCurveOrder(num)) return num;\n    throw new TypeError(\"Expected valid private scalar: 0 < scalar < curve.n\");\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = x * x * x % P;\n    const b3 = b2 * b2 * x % P;\n    const b6 = pow2(b3, _3n) * b3 % P;\n    const b9 = pow2(b6, _3n) * b3 % P;\n    const b11 = pow2(b9, _2n) * b2 % P;\n    const b22 = pow2(b11, _11n) * b11 % P;\n    const b44 = pow2(b22, _22n) * b22 % P;\n    const b88 = pow2(b44, _44n) * b44 % P;\n    const b176 = pow2(b88, _88n) * b88 % P;\n    const b220 = pow2(b176, _44n) * b44 % P;\n    const b223 = pow2(b220, _3n) * b3 % P;\n    const t1 = pow2(b223, _23n) * b22 % P;\n    const t2 = pow2(t1, _6n) * b2 % P;\n    const rt = pow2(t2, _2n);\n    const xc = rt * rt % P;\n    if (xc !== x) throw new Error(\"Cannot find square root\");\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i)=>{\n        if (num === _0n) return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly) return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen){\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n        if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== \"function\") throw new ShaError(\"hmacSha256Sync needs to be set\");\n    }\n    incr() {\n        if (this.counter >= 1000) throw new Error(\"Tried 1,000 k values for sign(), all were invalid\");\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0) return;\n        this.k = await this.hmac(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x00\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0) return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([\n            0x01\n        ]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while(len < this.qByteLen){\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k)) return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n) return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n) return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return {\n        sig,\n        recovery\n    };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else if (typeof key === \"number\" && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    } else if (typeof key === \"string\") {\n        if (key.length !== 2 * groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = hexToNumber(key);\n    } else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen) throw new Error(\"Expected 32 bytes of private key\");\n        num = bytesToNumber(key);\n    } else {\n        throw new TypeError(\"Expected valid private key\");\n    }\n    if (!isWithinCurveOrder(num)) throw new Error(\"Expected private key: 0 < key < n\");\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    } else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    } catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === \"string\";\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point) return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA)) throw new TypeError(\"getSharedSecret: first arg must be private key\");\n    if (!isProbPub(publicB)) throw new TypeError(\"getSharedSecret: second arg must be public key\");\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null) throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [\n        int2octets(d),\n        bits2octets(h1)\n    ];\n    if (extraEntropy != null) {\n        if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return {\n        seed,\n        m,\n        d\n    };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({\n        canonical: true,\n        der: true\n    }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [\n        hashed,\n        recovery\n    ] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while(!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while(!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\n\nconst vopts = {\n    strict: true\n};\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    } catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS()) return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    } catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R) return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s){\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error(\"Invalid signature\");\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()){\n        if (message == null) throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32) throw new TypeError(\"sign: Expected 32 bytes of aux randomness\");\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return {\n            point,\n            scalar,\n            x: point.toRawX()\n        };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n) throw new Error(\"sign: Creation of signature failed. k is zero\");\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return {\n            R,\n            rx,\n            k\n        };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error(\"sign: Invalid signature produced\");\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!await schnorrVerify(sig, m, px)) this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px)) this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw) sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey)\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r) return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    } catch (error) {\n        if (error instanceof ShaError) throw error;\n        return false;\n    }\n}\nconst schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: /*#__PURE__*/ (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(crypto__WEBPACK_IMPORTED_MODULE_0__, 2))),\n    web: typeof self === \"object\" && \"crypto\" in self ? self.crypto : undefined\n};\nconst TAGS = {\n    challenge: \"BIP0340/challenge\",\n    aux: \"BIP0340/aux\",\n    nonce: \"BIP0340/nonce\"\n};\nconst TAGGED_HASH_PREFIXES = {};\nconst utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey (privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash)=>{\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32)=>{\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        } else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        } else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: ()=>utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute (windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages)=>{\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest(\"SHA-256\", concatBytes(...messages));\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash(\"sha256\");\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages)=>{\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey(\"raw\", key, {\n                name: \"HMAC\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            }, false, [\n                \"sign\"\n            ]);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign(\"HMAC\", ckey, message);\n            return new Uint8Array(buffer);\n        } else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac(\"sha256\", key);\n            messages.forEach((m)=>hash.update(m));\n            return Uint8Array.from(hash.digest());\n        } else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages)=>{\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages)=>{\n        if (typeof _sha256Sync !== \"function\") throw new ShaError(\"sha256Sync is undefined, you need to set it\");\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get () {\n            return _sha256Sync;\n        },\n        set (val) {\n            if (!_sha256Sync) _sha256Sync = val;\n        }\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get () {\n            return _hmacSha256Sync;\n        },\n        set (val) {\n            if (!_hmacSha256Sync) _hmacSha256Sync = val;\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vYmxlL3NlY3AyNTZrMS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx1RUFBdUUsR0FDbEM7QUFDckMsTUFBTUMsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxNQUFNSixPQUFPO0FBQ25CLE1BQU1LLFFBQVFDLE9BQU9DLE1BQU0sQ0FBQztJQUN4QkMsR0FBR1Q7SUFDSFUsR0FBR1QsT0FBTztJQUNWVSxHQUFHVixPQUFPO0lBQ1ZXLEdBQUdYLE9BQU87SUFDVlksR0FBR1g7SUFDSFksSUFBSWIsT0FBTztJQUNYYyxJQUFJZCxPQUFPO0lBQ1hlLE1BQU1mLE9BQU87QUFDakI7QUFDQSxNQUFNZ0IsYUFBYSxDQUFDUixHQUFHQyxJQUFNLENBQUNELElBQUlDLElBQUlQLEdBQUUsSUFBS087QUFDN0MsTUFBTVEsT0FBTztJQUNURixNQUFNZixPQUFPO0lBQ2JrQixhQUFZQyxDQUFDO1FBQ1QsTUFBTSxFQUFFUixDQUFDLEVBQUUsR0FBR047UUFDZCxNQUFNZSxLQUFLcEIsT0FBTztRQUNsQixNQUFNcUIsS0FBSyxDQUFDcEIsTUFBTUQsT0FBTztRQUN6QixNQUFNc0IsS0FBS3RCLE9BQU87UUFDbEIsTUFBTXVCLEtBQUtIO1FBQ1gsTUFBTUksWUFBWXhCLE9BQU87UUFDekIsTUFBTXlCLEtBQUtULFdBQVdPLEtBQUtKLEdBQUdSO1FBQzlCLE1BQU1lLEtBQUtWLFdBQVcsQ0FBQ0ssS0FBS0YsR0FBR1I7UUFDL0IsSUFBSWdCLEtBQUtDLElBQUlULElBQUlNLEtBQUtMLEtBQUtNLEtBQUtKLElBQUlYO1FBQ3BDLElBQUlrQixLQUFLRCxJQUFJLENBQUNILEtBQUtKLEtBQUtLLEtBQUtILElBQUlaO1FBQ2pDLE1BQU1tQixRQUFRSCxLQUFLSDtRQUNuQixNQUFN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b2R1bGVzL0Bub2JsZS9zZWNwMjU2azEvbGliL2VzbS9pbmRleC5qcz80MzY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCAqIGFzIG5vZGVDcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF8zbiA9IEJpZ0ludCgzKTtcbmNvbnN0IF84biA9IEJpZ0ludCg4KTtcbmNvbnN0IENVUlZFID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufSk7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuY29uc3QgZW5kbyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIHNwbGl0U2NhbGFyKGspIHtcbiAgICAgICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgIH0sXG59O1xuY29uc3QgZmllbGRMZW4gPSAzMjtcbmNvbnN0IGdyb3VwTGVuID0gMzI7XG5jb25zdCBoYXNoTGVuID0gMzI7XG5jb25zdCBjb21wcmVzc2VkTGVuID0gZmllbGRMZW4gKyAxO1xuY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIGZpZWxkTGVuICsgMTtcbmV4cG9ydCB7IENVUlZFIH07XG5mdW5jdGlvbiB3ZWllcnN0cmFzcyh4KSB7XG4gICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICBjb25zdCB4MiA9IG1vZCh4ICogeCk7XG4gICAgY29uc3QgeDMgPSBtb2QoeDIgKiB4KTtcbiAgICByZXR1cm4gbW9kKHgzICsgYSAqIHggKyBiKTtcbn1cbmNvbnN0IFVTRV9FTkRPTU9SUEhJU00gPSBDVVJWRS5hID09PSBfMG47XG5jbGFzcyBTaGFFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEphY1BvaW50KG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBKYWNvYmlhblBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xufVxuY2xhc3MgSmFjb2JpYW5Qb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0phY29iaWFuUG9pbnQjZnJvbUFmZmluZTogZXhwZWN0ZWQgUG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5lcXVhbHMoUG9pbnQuWkVSTykpXG4gICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQocC54LCBwLnksIF8xbik7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FmZmluZUJhdGNoKHBvaW50cykge1xuICAgICAgICBjb25zdCB0b0ludiA9IGludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAueikpO1xuICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpO1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQudG9BZmZpbmVCYXRjaChwb2ludHMpLm1hcChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUpO1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0SmFjUG9pbnQob3RoZXIpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgcmV0dXJuIFUxID09PSBVMiAmJiBTMSA9PT0gUzI7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpLCB0aGlzLnopO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgQSA9IG1vZChYMSAqIFgxKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqIFkxKTtcbiAgICAgICAgY29uc3QgQyA9IG1vZChCICogQik7XG4gICAgICAgIGNvbnN0IHgxYiA9IFgxICsgQjtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKHgxYiAqIHgxYikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiBFKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGFzc2VydEphY1BvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyB4OiBYMSwgeTogWTEsIHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHg6IFgyLCB5OiBZMiwgejogWjIgfSA9IG90aGVyO1xuICAgICAgICBpZiAoWDIgPT09IF8wbiB8fCBZMiA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChYMSA9PT0gXzBuIHx8IFkxID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiBaMSk7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiBaMik7XG4gICAgICAgIGNvbnN0IFUxID0gbW9kKFgxICogWjJaMik7XG4gICAgICAgIGNvbnN0IFUyID0gbW9kKFgyICogWjFaMSk7XG4gICAgICAgIGNvbnN0IFMxID0gbW9kKG1vZChZMSAqIFoyKSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBTMiA9IG1vZChtb2QoWTIgKiBaMSkgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgSCA9IG1vZChVMiAtIFUxKTtcbiAgICAgICAgY29uc3QgciA9IG1vZChTMiAtIFMxKTtcbiAgICAgICAgaWYgKEggPT09IF8wbikge1xuICAgICAgICAgICAgaWYgKHIgPT09IF8wbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBISCA9IG1vZChIICogSCk7XG4gICAgICAgIGNvbnN0IEhISCA9IG1vZChIICogSEgpO1xuICAgICAgICBjb25zdCBWID0gbW9kKFUxICogSEgpO1xuICAgICAgICBjb25zdCBYMyA9IG1vZChyICogciAtIEhISCAtIF8ybiAqIFYpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChyICogKFYgLSBYMykgLSBTMSAqIEhISCk7XG4gICAgICAgIGNvbnN0IFozID0gbW9kKFoxICogWjIgKiBIKTtcbiAgICAgICAgcmV0dXJuIG5ldyBKYWNvYmlhblBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgUDAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGFyID09PSAnYmlnaW50JyAmJiBzY2FsYXIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBQMDtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIVVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGxldCBwID0gUDA7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgIGxldCBrMXAgPSBQMDtcbiAgICAgICAgbGV0IGsycCA9IFAwO1xuICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgIGsycCA9IG5ldyBKYWNvYmlhblBvaW50KG1vZChrMnAueCAqIGVuZG8uYmV0YSksIGsycC55LCBrMnAueik7XG4gICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgfVxuICAgIHByZWNvbXB1dGVXaW5kb3coVykge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gVVNFX0VORE9NT1JQSElTTSA/IDEyOCAvIFcgKyAxIDogMjU2IC8gVyArIDE7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDIgKiogKFcgLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgd05BRihuLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBpZiAoIWFmZmluZVBvaW50ICYmIHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuQkFTRSkpXG4gICAgICAgICAgICBhZmZpbmVQb2ludCA9IFBvaW50LkJBU0U7XG4gICAgICAgIGNvbnN0IFcgPSAoYWZmaW5lUG9pbnQgJiYgYWZmaW5lUG9pbnQuX1dJTkRPV19TSVpFKSB8fCAxO1xuICAgICAgICBpZiAoMjU2ICUgVykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCN3TkFGOiBJbnZhbGlkIHByZWNvbXB1dGF0aW9uIHdpbmRvdywgbXVzdCBiZSBwb3dlciBvZiAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNvbXB1dGVzID0gYWZmaW5lUG9pbnQgJiYgcG9pbnRQcmVjb21wdXRlcy5nZXQoYWZmaW5lUG9pbnQpO1xuICAgICAgICBpZiAoIXByZWNvbXB1dGVzKSB7XG4gICAgICAgICAgICBwcmVjb21wdXRlcyA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhXKTtcbiAgICAgICAgICAgIGlmIChhZmZpbmVQb2ludCAmJiBXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHV0ZXMgPSBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVoocHJlY29tcHV0ZXMpO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KGFmZmluZVBvaW50LCBwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHAgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGxldCBmID0gSmFjb2JpYW5Qb2ludC5CQVNFO1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gMSArIChVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyA6IDI1NiAvIFcpO1xuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpO1xuICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxO1xuICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhciwgYWZmaW5lUG9pbnQpIHtcbiAgICAgICAgbGV0IG4gPSBub3JtYWxpemVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICBsZXQgZmFrZTtcbiAgICAgICAgaWYgKFVTRV9FTkRPTU9SUEhJU00pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyLCBhZmZpbmVQb2ludCk7XG4gICAgICAgICAgICBrMXAgPSBjb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICBrMnAgPSBjb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBlbmRvLmJldGEpLCBrMnAueSwgazJwLnopO1xuICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG4gICAgdG9BZmZpbmUoaW52Wikge1xuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTyk7XG4gICAgICAgIGlmIChpbnZaID09IG51bGwpXG4gICAgICAgICAgICBpbnZaID0gaXMwID8gXzhuIDogaW52ZXJ0KHopO1xuICAgICAgICBjb25zdCBpejEgPSBpbnZaO1xuICAgICAgICBjb25zdCBpejIgPSBtb2QoaXoxICogaXoxKTtcbiAgICAgICAgY29uc3QgaXozID0gbW9kKGl6MiAqIGl6MSk7XG4gICAgICAgIGNvbnN0IGF4ID0gbW9kKHggKiBpejIpO1xuICAgICAgICBjb25zdCBheSA9IG1vZCh5ICogaXozKTtcbiAgICAgICAgY29uc3QgenogPSBtb2QoeiAqIGl6MSk7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbn1cbkphY29iaWFuUG9pbnQuQkFTRSA9IG5ldyBKYWNvYmlhblBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuKTtcbkphY29iaWFuUG9pbnQuWkVSTyA9IG5ldyBKYWNvYmlhblBvaW50KF8wbiwgXzFuLCBfMG4pO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICUgXzJuID09PSBfMG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzKHgpO1xuICAgICAgICBsZXQgeSA9IHNxcnRNb2QoeTIpO1xuICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgaWYgKGlzU2hvcnQpIHtcbiAgICAgICAgICAgIGlmIChpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc0ZpcnN0Qnl0ZU9kZCA9IChieXRlc1swXSAmIDEpID09PSAxO1xuICAgICAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgeSA9IG1vZCgteSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHBvaW50LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VbmNvbXByZXNzZWRIZXgoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoYnl0ZXMuc3ViYXJyYXkoMSwgZmllbGRMZW4gKyAxKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KGZpZWxkTGVuICsgMSwgZmllbGRMZW4gKiAyICsgMSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSBmaWVsZExlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21Db21wcmVzc2VkSGV4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjb3ZlcnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlcjogaW52YWxpZCByZWNvdmVyeSBiaXQnKTtcbiAgICAgICAgY29uc3QgaCA9IHRydW5jYXRlSGFzaChlbnN1cmVCeXRlcyhtc2dIYXNoKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJhZGogPSByZWNvdmVyeSA9PT0gMiB8fCByZWNvdmVyeSA9PT0gMyA/IHIgKyBuIDogcjtcbiAgICAgICAgY29uc3QgcmludiA9IGludmVydChyYWRqLCBuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoLWggKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgdTIgPSBtb2QocyAqIHJpbnYsIG4pO1xuICAgICAgICBjb25zdCBwcmVmaXggPSByZWNvdmVyeSAmIDEgPyAnMDMnIDogJzAyJztcbiAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG8zMmJTdHIocmFkaikpO1xuICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpO1xuICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWNvdmVyIHNpZ25hdHVyZTogcG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvSGV4KGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICB0b0hleChpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB4ID0gbnVtVG8zMmJTdHIodGhpcy54KTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy5oYXNFdmVuWSgpID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7eH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAwNCR7eH0ke251bVRvMzJiU3RyKHRoaXMueSl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0hleFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KHRydWUpLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0b1Jhd1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCBtc2cgPSAnUG9pbnQgaXMgbm90IG9uIGVsbGlwdGljIGN1cnZlJztcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkgfHwgIWlzVmFsaWRGaWVsZEVsZW1lbnQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IG1vZCh5ICogeSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3MoeCk7XG4gICAgICAgIGlmIChtb2QobGVmdCAtIHJpZ2h0KSAhPT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgbW9kKC10aGlzLnkpKTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmRvdWJsZSgpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLmFkZChKYWNvYmlhblBvaW50LmZyb21BZmZpbmUob3RoZXIpKS50b0FmZmluZSgpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKS5tdWx0aXBseShzY2FsYXIsIHRoaXMpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgUCA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSh0aGlzKTtcbiAgICAgICAgY29uc3QgYVAgPSBhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8IHRoaXMgIT09IFBvaW50LkJBU0UgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKTtcbiAgICAgICAgY29uc3QgYlEgPSBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUoUSkubXVsdGlwbHlVbnNhZmUoYik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGFQLmFkZChiUSk7XG4gICAgICAgIHJldHVybiBzdW0uZXF1YWxzKEphY29iaWFuUG9pbnQuWkVSTykgPyB1bmRlZmluZWQgOiBzdW0udG9BZmZpbmUoKTtcbiAgICB9XG59XG5Qb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSk7XG5Qb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzBuKTtcbmZ1bmN0aW9uIHNsaWNlREVSKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSA+PSA4ID8gJzAwJyArIHMgOiBzO1xufVxuZnVuY3Rpb24gcGFyc2VERVJJbnQoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGhgKTtcbiAgICB9XG4gICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiByZXNbMV0gPD0gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHRyYWlsaW5nIGxlbmd0aCcpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXRhOiBieXRlc1RvTnVtYmVyKHJlcyksIGxlZnQ6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlREVSU2lnbmF0dXJlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT0gMHgzMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIHRhZzogJHtieXRlc1RvSGV4KGRhdGEpfWApO1xuICAgIH1cbiAgICBpZiAoZGF0YVsxXSAhPT0gZGF0YS5sZW5ndGggLSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhOiByLCBsZWZ0OiBzQnl0ZXMgfSA9IHBhcnNlREVSSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgIGNvbnN0IHsgZGF0YTogcywgbGVmdDogckJ5dGVzTGVmdCB9ID0gcGFyc2VERVJJbnQoc0J5dGVzKTtcbiAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nOiAke2J5dGVzVG9IZXgockJ5dGVzTGVmdCl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKHIsIHMpIHtcbiAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAnU2lnbmF0dXJlLmZyb21Db21wYWN0JztcbiAgICAgICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnICYmICFhcnIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke25hbWV9OiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCBzdHIgPSBhcnIgPyBieXRlc1RvSGV4KGhleCkgOiBoZXg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSAxMjgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IEV4cGVjdGVkIDY0LWJ5dGUgaGV4YCk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGhleFRvTnVtYmVyKHN0ci5zbGljZSgwLCA2NCkpLCBoZXhUb051bWJlcihzdHIuc2xpY2UoNjQsIDEyOCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGhleCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2lnbmF0dXJlLmZyb21ERVI6IEV4cGVjdGVkIHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gcGFyc2VERVJTaWduYXR1cmUoYXJyID8gaGV4IDogaGV4VG9CeXRlcyhoZXgpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tREVSKGhleCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpZ25hdHVyZTogciBtdXN0IGJlIDAgPCByIDwgbicpO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHMgbXVzdCBiZSAwIDwgcyA8IG4nKTtcbiAgICB9XG4gICAgaGFzSGlnaFMoKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRS5uID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIHRoaXMucyA+IEhBTEY7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kKC10aGlzLnMsIENVUlZFLm4pKSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgY29uc3QgckhleCA9IHNsaWNlREVSKG51bWJlclRvSGV4VW5wYWRkZWQodGhpcy5yKSk7XG4gICAgICAgIGNvbnN0IHNIZXhMID0gc0hleC5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBySGV4TCA9IHJIZXgubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleEwpO1xuICAgICAgICBjb25zdCByTGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4TCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleEwgKyBzSGV4TCArIDQpO1xuICAgICAgICByZXR1cm4gYDMwJHtsZW5ndGh9MDIke3JMZW59JHtySGV4fTAyJHtzTGVufSR7c0hleH1gO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUlJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RFUkhleCgpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChiKSA9PiBiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IFBPV18yXzI1NiA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpO1xuZnVuY3Rpb24gbnVtVG8zMmJTdHIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJpZ2ludCcpO1xuICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgUE9XXzJfMjU2KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXIgMCA8PSBuIDwgMl4yNTYnKTtcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKTtcbn1cbmZ1bmN0aW9uIG51bVRvMzJiKG51bSkge1xuICAgIGNvbnN0IGIgPSBoZXhUb0J5dGVzKG51bVRvMzJiU3RyKG51bSkpO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3I6IGV4cGVjdGVkIDMyIGJ5dGVzJyk7XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvTnVtYmVyOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW0pO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIHNjYWxhcjogMCA8IHNjYWxhciA8IGN1cnZlLm4nKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3FydE1vZCh4KSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCBfNm4gPSBCaWdJbnQoNik7XG4gICAgY29uc3QgXzExbiA9IEJpZ0ludCgxMSk7XG4gICAgY29uc3QgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyk7XG4gICAgY29uc3QgXzQ0biA9IEJpZ0ludCg0NCk7XG4gICAgY29uc3QgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeCAqIHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHgpICUgUDtcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybikgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4bikgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82bikgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJ0ID0gcG93Mih0MiwgXzJuKTtcbiAgICBjb25zdCB4YyA9IChydCAqIHJ0KSAlIFA7XG4gICAgaWYgKHhjICE9PSB4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJ0O1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHNjcmF0Y2ggPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBfMW4pO1xuICAgIGNvbnN0IGludmVydGVkID0gaW52ZXJ0KGxhc3RNdWx0aXBsaWVkLCBwKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gbW9kKGFjYyAqIHNjcmF0Y2hbaV0sIHApO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiBzY3JhdGNoO1xufVxuZnVuY3Rpb24gYml0czJpbnRfMihieXRlcykge1xuICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIGdyb3VwTGVuICogODtcbiAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyKGJ5dGVzKTtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG59XG5mdW5jdGlvbiB0cnVuY2F0ZUhhc2goaGFzaCwgdHJ1bmNhdGVPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCBoID0gYml0czJpbnRfMihoYXNoKTtcbiAgICBpZiAodHJ1bmNhdGVPbmx5KVxuICAgICAgICByZXR1cm4gaDtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIHJldHVybiBoID49IG4gPyBoIC0gbiA6IGg7XG59XG5sZXQgX3NoYTI1NlN5bmM7XG5sZXQgX2htYWNTaGEyNTZTeW5jO1xuY2xhc3MgSG1hY0RyYmcge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hMZW4sIHFCeXRlTGVuKSB7XG4gICAgICAgIHRoaXMuaGFzaExlbiA9IGhhc2hMZW47XG4gICAgICAgIHRoaXMucUJ5dGVMZW4gPSBxQnl0ZUxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB0aGlzLnYgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDEpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgVWludDhBcnJheShoYXNoTGVuKS5maWxsKDApO1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIH1cbiAgICBobWFjKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gdXRpbHMuaG1hY1NoYTI1Nih0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGhtYWNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICByZXR1cm4gX2htYWNTaGEyNTZTeW5jKHRoaXMuaywgLi4udmFsdWVzKTtcbiAgICB9XG4gICAgY2hlY2tTeW5jKCkge1xuICAgICAgICBpZiAodHlwZW9mIF9obWFjU2hhMjU2U3luYyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBTaGFFcnJvcignaG1hY1NoYTI1NlN5bmMgbmVlZHMgdG8gYmUgc2V0Jyk7XG4gICAgfVxuICAgIGluY3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgMSwwMDAgayB2YWx1ZXMgZm9yIHNpZ24oKSwgYWxsIHdlcmUgaW52YWxpZCcpO1xuICAgICAgICB0aGlzLmNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZWVkKHNlZWQgPSBuZXcgVWludDhBcnJheSgpKSB7XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAxXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICB9XG4gICAgcmVzZWVkU3luYyhzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmNoZWNrU3luYygpO1xuICAgICAgICB0aGlzLmsgPSB0aGlzLmhtYWNTeW5jKHRoaXMudiwgVWludDhBcnJheS5mcm9tKFsweDAwXSksIHNlZWQpO1xuICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgdGhpcy5pbmNyKCk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHRoaXMucUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB0aGlzLnYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLnYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH1cbiAgICBnZW5lcmF0ZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTeW5jKCk7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCB0aGlzLnFCeXRlTGVuKSB7XG4gICAgICAgICAgICB0aGlzLnYgPSB0aGlzLmhtYWNTeW5jKHRoaXMudik7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHRoaXMudi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHRoaXMudi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5QO1xufVxuZnVuY3Rpb24ga21kVG9TaWcoa0J5dGVzLCBtLCBkLCBsb3dTID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgayA9IHRydW5jYXRlSGFzaChrQnl0ZXMsIHRydWUpO1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3Qga2ludiA9IGludmVydChrLCBuKTtcbiAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKTtcbiAgICBjb25zdCByID0gbW9kKHEueCwgbik7XG4gICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHMgPSBtb2Qoa2ludiAqIG1vZChtICsgZCAqIHIsIG4pLCBuKTtcbiAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gc2lnLnIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTtcbiAgICBpZiAobG93UyAmJiBzaWcuaGFzSGlnaFMoKSkge1xuICAgICAgICBzaWcgPSBzaWcubm9ybWFsaXplUygpO1xuICAgICAgICByZWNvdmVyeSBePSAxO1xuICAgIH1cbiAgICByZXR1cm4geyBzaWcsIHJlY292ZXJ5IH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KGtleSkge1xuICAgIGxldCBudW07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIG51bSA9IGtleTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIoa2V5KSAmJiBrZXkgPiAwKSB7XG4gICAgICAgIG51bSA9IEJpZ0ludChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMiAqIGdyb3VwTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIGtleScpO1xuICAgICAgICBudW0gPSBoZXhUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSBncm91cExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gYnl0ZXNUb051bWJlcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcml2YXRlIGtleTogMCA8IGtleSA8IG4nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgICBwdWJsaWNLZXkuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBTaWduYXR1cmUpIHtcbiAgICAgICAgc2lnbmF0dXJlLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbURFUihzaWduYXR1cmUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzaWduYXR1cmUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVNpZ25hdHVyZShtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5mdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgaWYgKGFycilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICBpZiAoc3RyKVxuICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuICogMiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbiAqIDI7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0U2hhcmVkU2VjcmV0OiBmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXRTaGFyZWRTZWNyZXQ6IHNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgYiA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNCKTtcbiAgICBiLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmZ1bmN0aW9uIGJpdHMyaW50KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBieXRlcy5sZW5ndGggPiBmaWVsZExlbiA/IGJ5dGVzLnNsaWNlKDAsIGZpZWxkTGVuKSA6IGJ5dGVzO1xuICAgIHJldHVybiBieXRlc1RvTnVtYmVyKHNsaWNlKTtcbn1cbmZ1bmN0aW9uIGJpdHMyb2N0ZXRzKGJ5dGVzKSB7XG4gICAgY29uc3QgejEgPSBiaXRzMmludChieXRlcyk7XG4gICAgY29uc3QgejIgPSBtb2QoejEsIENVUlZFLm4pO1xuICAgIHJldHVybiBpbnQyb2N0ZXRzKHoyIDwgXzBuID8gejEgOiB6Mik7XG59XG5mdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgIHJldHVybiBudW1UbzMyYihudW0pO1xufVxuZnVuY3Rpb24gaW5pdFNpZ0FyZ3MobXNnSGFzaCwgcHJpdmF0ZUtleSwgZXh0cmFFbnRyb3B5KSB7XG4gICAgaWYgKG1zZ0hhc2ggPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduOiBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2gsIG5vdCBcIiR7bXNnSGFzaH1cImApO1xuICAgIGNvbnN0IGgxID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgY29uc3QgZCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgYml0czJvY3RldHMoaDEpXTtcbiAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGV4dHJhRW50cm9weSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGV4dHJhRW50cm9weSA9IHV0aWxzLnJhbmRvbUJ5dGVzKGZpZWxkTGVuKTtcbiAgICAgICAgY29uc3QgZSA9IGVuc3VyZUJ5dGVzKGV4dHJhRW50cm9weSk7XG4gICAgICAgIGlmIChlLmxlbmd0aCAhPT0gZmllbGRMZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ246IEV4cGVjdGVkICR7ZmllbGRMZW59IGJ5dGVzIG9mIGV4dHJhIGRhdGFgKTtcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTtcbiAgICBjb25zdCBtID0gYml0czJpbnQoaDEpO1xuICAgIHJldHVybiB7IHNlZWQsIG0sIGQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2lnKHJlY1NpZywgb3B0cykge1xuICAgIGNvbnN0IHsgc2lnLCByZWNvdmVyeSB9ID0gcmVjU2lnO1xuICAgIGNvbnN0IHsgZGVyLCByZWNvdmVyZWQgfSA9IE9iamVjdC5hc3NpZ24oeyBjYW5vbmljYWw6IHRydWUsIGRlcjogdHJ1ZSB9LCBvcHRzKTtcbiAgICBjb25zdCBoYXNoZWQgPSBkZXIgPyBzaWcudG9ERVJSYXdCeXRlcygpIDogc2lnLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgcmV0dXJuIHJlY292ZXJlZCA/IFtoYXNoZWQsIHJlY292ZXJ5XSA6IGhhc2hlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBzZWVkLCBtLCBkIH0gPSBpbml0U2lnQXJncyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzLmV4dHJhRW50cm9weSk7XG4gICAgY29uc3QgZHJiZyA9IG5ldyBIbWFjRHJiZyhoYXNoTGVuLCBncm91cExlbik7XG4gICAgYXdhaXQgZHJiZy5yZXNlZWQoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhhd2FpdCBkcmJnLmdlbmVyYXRlKCksIG0sIGQsIG9wdHMuY2Fub25pY2FsKSkpXG4gICAgICAgIGF3YWl0IGRyYmcucmVzZWVkKCk7XG4gICAgcmV0dXJuIGZpbmFsaXplU2lnKHNpZywgb3B0cyk7XG59XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBjb25zdCBkcmJnID0gbmV3IEhtYWNEcmJnKGhhc2hMZW4sIGdyb3VwTGVuKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgbGV0IHNpZztcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhkcmJnLmdlbmVyYXRlU3luYygpLCBtLCBkLCBvcHRzLmNhbm9uaWNhbCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydCB7IHNpZ24sIHNpZ25TeW5jIH07XG5jb25zdCB2b3B0cyA9IHsgc3RyaWN0OiB0cnVlIH07XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gdm9wdHMpIHtcbiAgICBsZXQgc2lnO1xuICAgIHRyeSB7XG4gICAgICAgIHNpZyA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMobXNnSGFzaCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgciwgcyB9ID0gc2lnO1xuICAgIGlmIChvcHRzLnN0cmljdCAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGggPSB0cnVuY2F0ZUhhc2gobXNnSGFzaCk7XG4gICAgbGV0IFA7XG4gICAgdHJ5IHtcbiAgICAgICAgUCA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHNpbnYgPSBpbnZlcnQocywgbik7XG4gICAgY29uc3QgdTEgPSBtb2QoaCAqIHNpbnYsIG4pO1xuICAgIGNvbnN0IHUyID0gbW9kKHIgKiBzaW52LCBuKTtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpO1xuICAgIGlmICghUilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHYgPSBtb2QoUi54LCBuKTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbn1cbmZ1bmN0aW9uIHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuY2xhc3MgU2Nobm9yclNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3Iociwgcykge1xuICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuc3VyZUJ5dGVzKGhleCk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDY0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4OiBleHBlY3RlZCA2NCBieXRlcywgbm90ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgwLCAzMikpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlcihieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2hub3JyU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQocikgfHwgIWlzV2l0aGluQ3VydmVPcmRlcihzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleCgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdYKCk7XG59XG5jbGFzcyBJbnRlcm5hbFNjaG5vcnJTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSB1dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzaWduOiBFeHBlY3RlZCB2YWxpZCBtZXNzYWdlLCBub3QgXCIke21lc3NhZ2V9XCJgKTtcbiAgICAgICAgdGhpcy5tID0gZW5zdXJlQnl0ZXMobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgeCwgc2NhbGFyIH0gPSB0aGlzLmdldFNjYWxhcihub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgdGhpcy5weCA9IHg7XG4gICAgICAgIHRoaXMuZCA9IHNjYWxhcjtcbiAgICAgICAgdGhpcy5yYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGF1eCByYW5kb21uZXNzJyk7XG4gICAgfVxuICAgIGdldFNjYWxhcihwcml2KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdik7XG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHBvaW50Lmhhc0V2ZW5ZKCkgPyBwcml2IDogQ1VSVkUubiAtIHByaXY7XG4gICAgICAgIHJldHVybiB7IHBvaW50LCBzY2FsYXIsIHg6IHBvaW50LnRvUmF3WCgpIH07XG4gICAgfVxuICAgIGluaXROb25jZShkLCB0MGgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyKHQwaCkpO1xuICAgIH1cbiAgICBmaW5hbGl6ZU5vbmNlKGswaCkge1xuICAgICAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgICAgICBpZiAoazAgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogQ3JlYXRpb24gb2Ygc2lnbmF0dXJlIGZhaWxlZC4gayBpcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQ6IFIsIHg6IHJ4LCBzY2FsYXI6IGsgfSA9IHRoaXMuZ2V0U2NhbGFyKGswKTtcbiAgICAgICAgcmV0dXJuIHsgUiwgcngsIGsgfTtcbiAgICB9XG4gICAgZmluYWxpemVTaWcoUiwgaywgZSwgZCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUoUi54LCBtb2QoayArIGUgKiBkLCBDVVJWRS5uKSkudG9SYXdCeXRlcygpO1xuICAgIH1cbiAgICBlcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIH1cbiAgICBhc3luYyBjYWxjKCkge1xuICAgICAgICBjb25zdCB7IG0sIGQsIHB4LCByYW5kIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YWcgPSB1dGlscy50YWdnZWRIYXNoO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgYXdhaXQgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZShhd2FpdCB0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIShhd2FpdCBzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKSlcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgY2FsY1N5bmMoKSB7XG4gICAgICAgIGNvbnN0IHsgbSwgZCwgcHgsIHJhbmQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRhZyA9IHV0aWxzLnRhZ2dlZEhhc2hTeW5jO1xuICAgICAgICBjb25zdCB0ID0gdGhpcy5pbml0Tm9uY2UoZCwgdGFnKFRBR1MuYXV4LCByYW5kKSk7XG4gICAgICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IHRoaXMuZmluYWxpemVOb25jZSh0YWcoVEFHUy5ub25jZSwgdCwgcHgsIG0pKTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZSh0YWcoVEFHUy5jaGFsbGVuZ2UsIHJ4LCBweCwgbSkpO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmZpbmFsaXplU2lnKFIsIGssIGUsIGQpO1xuICAgICAgICBpZiAoIXNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJTaWduKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsYygpO1xufVxuZnVuY3Rpb24gc2Nobm9yclNpZ25TeW5jKG1zZywgcHJpdktleSwgYXV4UmFuZCkge1xuICAgIHJldHVybiBuZXcgSW50ZXJuYWxTY2hub3JyU2lnbmF0dXJlKG1zZywgcHJpdktleSwgYXV4UmFuZCkuY2FsY1N5bmMoKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmF3ID0gc2lnbmF0dXJlIGluc3RhbmNlb2YgU2Nobm9yclNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWcgPSByYXcgPyBzaWduYXR1cmUgOiBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICBpZiAocmF3KVxuICAgICAgICBzaWcuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zaWcsXG4gICAgICAgIG06IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpLFxuICAgICAgICBQOiBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpIHtcbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCBub3JtYWxpemVQcml2YXRlS2V5KHMpLCBtb2QoLWUsIENVUlZFLm4pKTtcbiAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IHNjaG5vcnJDaGFsbGVuZ2VGaW5hbGl6ZShhd2FpdCB1dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnlTeW5jKHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyByLCBzLCBtLCBQIH0gPSBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IGUgPSBzY2hub3JyQ2hhbGxlbmdlRmluYWxpemUodXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTaGFFcnJvcilcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSB7XG4gICAgU2lnbmF0dXJlOiBTY2hub3JyU2lnbmF0dXJlLFxuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgc2lnblN5bmM6IHNjaG5vcnJTaWduU3luYyxcbiAgICB2ZXJpZnlTeW5jOiBzY2hub3JyVmVyaWZ5U3luYyxcbn07XG5Qb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuY29uc3QgY3J5cHRvID0ge1xuICAgIG5vZGU6IG5vZGVDcnlwdG8sXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IFRBR1MgPSB7XG4gICAgY2hhbGxlbmdlOiAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAgIGF1eDogJ0JJUDAzNDAvYXV4JyxcbiAgICBub25jZTogJ0JJUDAzNDAvbm9uY2UnLFxufTtcbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYnl0ZXNUb0hleCxcbiAgICBoZXhUb0J5dGVzLFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIG1vZCxcbiAgICBpbnZlcnQsXG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYmlnaW50VG8zMkJ5dGVzOiBudW1UbzMyYixcbiAgICBfbm9ybWFsaXplUHJpdmF0ZUtleTogbm9ybWFsaXplUHJpdmF0ZUtleSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbiA9IGdyb3VwTGVuICsgODtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoIDwgbWluTGVuIHx8IGhhc2gubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODZgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBtb2QoYnl0ZXNUb051bWJlcihoYXNoKSwgQ1VSVkUubiAtIF8xbikgKyBfMW47XG4gICAgICAgIHJldHVybiBudW1UbzMyYihudW0pO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IChieXRlc0xlbmd0aCA9IDMyKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICByZXR1cm4gY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyByYW5kb21CeXRlcyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB1dGlscy5oYXNoVG9Qcml2YXRlS2V5KHV0aWxzLnJhbmRvbUJ5dGVzKGdyb3VwTGVuICsgOCkpLFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBwb2ludCA9PT0gUG9pbnQuQkFTRSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfM24pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG4gICAgc2hhMjU2OiBhc3luYyAoLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGNyeXB0by53ZWIuc3VidGxlLmRpZ2VzdCgnU0hBLTI1NicsIGNvbmNhdEJ5dGVzKC4uLm1lc3NhZ2VzKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIYXNoIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHNoYTI1NiBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG1hY1NoYTI1NjogYXN5bmMgKGtleSwgLi4ubWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKGNyeXB0by53ZWIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNrZXkgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGtleSwgeyBuYW1lOiAnSE1BQycsIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0gfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjb25jYXRCeXRlcyguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5zaWduKCdITUFDJywgY2tleSwgbWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcnlwdG8ubm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjcmVhdGVIbWFjIH0gPSBjcnlwdG8ubm9kZTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrZXkpO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaCgobSkgPT4gaGFzaC51cGRhdGUobSkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgaG1hYy1zaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICBobWFjU2hhMjU2U3luYzogdW5kZWZpbmVkLFxuICAgIHRhZ2dlZEhhc2g6IGFzeW5jICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGF3YWl0IHV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuc2hhMjU2KHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHRhZ2dlZEhhc2hTeW5jOiAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIF9zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoYUVycm9yKCdzaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IF9zaGEyNTZTeW5jKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2hhMjU2U3luYyh0YWdQLCAuLi5tZXNzYWdlcyk7XG4gICAgfSxcbiAgICBfSmFjb2JpYW5Qb2ludDogSmFjb2JpYW5Qb2ludCxcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh1dGlscywge1xuICAgIHNoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zaGEyNTZTeW5jO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICBpZiAoIV9zaGEyNTZTeW5jKVxuICAgICAgICAgICAgICAgIF9zaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgaG1hY1NoYTI1NlN5bmM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9obWFjU2hhMjU2U3luYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbCkge1xuICAgICAgICAgICAgaWYgKCFfaG1hY1NoYTI1NlN5bmMpXG4gICAgICAgICAgICAgICAgX2htYWNTaGEyNTZTeW5jID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG59KTtcbiJdLCJuYW1lcyI6WyJub2RlQ3J5cHRvIiwiXzBuIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzhuIiwiQ1VSVkUiLCJPYmplY3QiLCJmcmVlemUiLCJhIiwiYiIsIlAiLCJuIiwiaCIsIkd4IiwiR3kiLCJiZXRhIiwiZGl2TmVhcmVzdCIsImVuZG8iLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJiMiIsIlBPV18yXzEyOCIsImMxIiwiYzIiLCJrMSIsIm1vZCIsImsyIiwiazFuZWciLCJrMm5lZyIsIkVycm9yIiwiZmllbGRMZW4iLCJncm91cExlbiIsImhhc2hMZW4iLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwid2VpZXJzdHJhc3MiLCJ4IiwieDIiLCJ4MyIsIlVTRV9FTkRPTU9SUEhJU00iLCJTaGFFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImFzc2VydEphY1BvaW50Iiwib3RoZXIiLCJKYWNvYmlhblBvaW50IiwiVHlwZUVycm9yIiwieSIsInoiLCJmcm9tQWZmaW5lIiwicCIsIlBvaW50IiwiZXF1YWxzIiwiWkVSTyIsInRvQWZmaW5lQmF0Y2giLCJwb2ludHMiLCJ0b0ludiIsImludmVydEJhdGNoIiwibWFwIiwiaSIsInRvQWZmaW5lIiwibm9ybWFsaXplWiIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIloxWjEiLCJaMloyIiwiVTEiLCJVMiIsIlMxIiwiUzIiLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJ4MWIiLCJEIiwiRSIsIkYiLCJYMyIsIlkzIiwiWjMiLCJhZGQiLCJIIiwiciIsIkhIIiwiSEhIIiwiViIsInN1YnRyYWN0IiwibXVsdGlwbHlVbnNhZmUiLCJzY2FsYXIiLCJQMCIsIm5vcm1hbGl6ZVNjYWxhciIsImQiLCJrMXAiLCJrMnAiLCJwcmVjb21wdXRlV2luZG93IiwiVyIsIndpbmRvd3MiLCJiYXNlIiwid2luZG93IiwicHVzaCIsIndOQUYiLCJhZmZpbmVQb2ludCIsIkJBU0UiLCJfV0lORE9XX1NJWkUiLCJwcmVjb21wdXRlcyIsInBvaW50UHJlY29tcHV0ZXMiLCJnZXQiLCJzZXQiLCJmIiwid2luZG93U2l6ZSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJOdW1iZXIiLCJvZmZzZXQxIiwib2Zmc2V0MiIsIk1hdGgiLCJhYnMiLCJjb25kMSIsImNvbmQyIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHkiLCJwb2ludCIsImZha2UiLCJmMXAiLCJmMnAiLCJpbnZaIiwiaXMwIiwiaW52ZXJ0IiwiaXoxIiwiaXoyIiwiaXozIiwiYXgiLCJheSIsInp6IiwiY29uZGl0aW9uIiwiaXRlbSIsIm5lZyIsIldlYWtNYXAiLCJfc2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsImhhc0V2ZW5ZIiwiZnJvbUNvbXByZXNzZWRIZXgiLCJieXRlcyIsImlzU2hvcnQiLCJsZW5ndGgiLCJieXRlc1RvTnVtYmVyIiwic3ViYXJyYXkiLCJpc1ZhbGlkRmllbGRFbGVtZW50IiwieTIiLCJzcXJ0TW9kIiwiaXNZT2RkIiwiaXNGaXJzdEJ5dGVPZGQiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21VbmNvbXByZXNzZWRIZXgiLCJmcm9tSGV4IiwiaGV4IiwiZW5zdXJlQnl0ZXMiLCJsZW4iLCJoZWFkZXIiLCJmcm9tUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJub3JtYWxpemVQcml2YXRlS2V5IiwiZnJvbVNpZ25hdHVyZSIsIm1zZ0hhc2giLCJzaWduYXR1cmUiLCJyZWNvdmVyeSIsInMiLCJub3JtYWxpemVTaWduYXR1cmUiLCJpbmNsdWRlcyIsInRydW5jYXRlSGFzaCIsInJhZGoiLCJyaW52IiwidTEiLCJ1MiIsInByZWZpeCIsIlIiLCJudW1UbzMyYlN0ciIsIlEiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJoZXhUb0J5dGVzIiwidG9IZXgiLCJ0b0hleFgiLCJzbGljZSIsInRvUmF3WCIsIm1zZyIsImxlZnQiLCJyaWdodCIsImFQIiwiYlEiLCJzdW0iLCJ1bmRlZmluZWQiLCJzbGljZURFUiIsInBhcnNlSW50IiwicGFyc2VERVJJbnQiLCJkYXRhIiwiYnl0ZXNUb0hleCIsInJlcyIsInBhcnNlREVSU2lnbmF0dXJlIiwic0J5dGVzIiwickJ5dGVzTGVmdCIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiYXJyIiwiVWludDhBcnJheSIsIm5hbWUiLCJzdHIiLCJoZXhUb051bWJlciIsImZyb21ERVIiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJoYXNIaWdoUyIsIkhBTEYiLCJub3JtYWxpemVTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4Iiwic0hleCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJySGV4Iiwic0hleEwiLCJySGV4TCIsInNMZW4iLCJyTGVuIiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJjb25jYXRCeXRlcyIsImFycmF5cyIsImV2ZXJ5IiwicmVkdWNlIiwicmVzdWx0IiwicGFkIiwiaGV4ZXMiLCJBcnJheSIsImZyb20iLCJ2IiwidG9TdHJpbmciLCJwYWRTdGFydCIsInVpbnQ4YSIsIlBPV18yXzI1NiIsIm51bSIsIm51bVRvMzJiIiwiYXJyYXkiLCJqIiwiaGV4Qnl0ZSIsImJ5dGUiLCJpc05hTiIsImlzU2FmZUludGVnZXIiLCJwb3cyIiwicG93ZXIiLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJydCIsInhjIiwibnVtYmVyIiwibW9kdWxvIiwidSIsInEiLCJtIiwiZ2NkIiwibnVtcyIsInNjcmF0Y2giLCJsYXN0TXVsdGlwbGllZCIsImFjYyIsImludmVydGVkIiwicmVkdWNlUmlnaHQiLCJiaXRzMmludF8yIiwiZGVsdGEiLCJoYXNoIiwidHJ1bmNhdGVPbmx5IiwiX3NoYTI1NlN5bmMiLCJfaG1hY1NoYTI1NlN5bmMiLCJIbWFjRHJiZyIsInFCeXRlTGVuIiwiZmlsbCIsImNvdW50ZXIiLCJobWFjIiwidmFsdWVzIiwidXRpbHMiLCJobWFjU2hhMjU2IiwiaG1hY1N5bmMiLCJjaGVja1N5bmMiLCJpbmNyIiwicmVzZWVkIiwic2VlZCIsInJlc2VlZFN5bmMiLCJnZW5lcmF0ZSIsIm91dCIsInNsIiwiZ2VuZXJhdGVTeW5jIiwia21kVG9TaWciLCJrQnl0ZXMiLCJsb3dTIiwia2ludiIsInNpZyIsImtleSIsIm5vcm1hbGl6ZVB1YmxpY0tleSIsInB1YmxpY0tleSIsImVycm9yIiwiZ2V0UHVibGljS2V5IiwicmVjb3ZlclB1YmxpY0tleSIsImlzUHJvYlB1YiIsImdldFNoYXJlZFNlY3JldCIsInByaXZhdGVBIiwicHVibGljQiIsImJpdHMyaW50IiwiYml0czJvY3RldHMiLCJ6MSIsInoyIiwiaW50Mm9jdGV0cyIsImluaXRTaWdBcmdzIiwiZXh0cmFFbnRyb3B5IiwiaDEiLCJzZWVkQXJncyIsInJhbmRvbUJ5dGVzIiwiZSIsImZpbmFsaXplU2lnIiwicmVjU2lnIiwib3B0cyIsImRlciIsInJlY292ZXJlZCIsImFzc2lnbiIsImNhbm9uaWNhbCIsImhhc2hlZCIsInNpZ24iLCJwcml2S2V5IiwiZHJiZyIsInNpZ25TeW5jIiwidm9wdHMiLCJzdHJpY3QiLCJ2ZXJpZnkiLCJzaW52Iiwic2Nobm9yckNoYWxsZW5nZUZpbmFsaXplIiwiY2giLCJTY2hub3JyU2lnbmF0dXJlIiwic2Nobm9yckdldFB1YmxpY0tleSIsIkludGVybmFsU2Nobm9yclNpZ25hdHVyZSIsImF1eFJhbmQiLCJnZXRTY2FsYXIiLCJweCIsInJhbmQiLCJwcml2IiwiaW5pdE5vbmNlIiwidDBoIiwiZmluYWxpemVOb25jZSIsImswaCIsImswIiwicngiLCJjYWxjIiwidGFnIiwidGFnZ2VkSGFzaCIsInQiLCJUQUdTIiwiYXV4Iiwibm9uY2UiLCJjaGFsbGVuZ2UiLCJzY2hub3JyVmVyaWZ5IiwiY2FsY1N5bmMiLCJ0YWdnZWRIYXNoU3luYyIsInNjaG5vcnJWZXJpZnlTeW5jIiwic2Nobm9yclNpZ24iLCJzY2hub3JyU2lnblN5bmMiLCJpbml0U2Nobm9yclZlcmlmeSIsInJhdyIsImZpbmFsaXplU2Nobm9yclZlcmlmeSIsInNjaG5vcnIiLCJ2ZXJpZnlTeW5jIiwiY3J5cHRvIiwibm9kZSIsIndlYiIsInNlbGYiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsImlzVmFsaWRQcml2YXRlS2V5IiwiX2JpZ2ludFRvMzJCeXRlcyIsIl9ub3JtYWxpemVQcml2YXRlS2V5IiwiaGFzaFRvUHJpdmF0ZUtleSIsIm1pbkxlbiIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tUHJpdmF0ZUtleSIsInByZWNvbXB1dGUiLCJjYWNoZWQiLCJzaGEyNTYiLCJtZXNzYWdlcyIsImJ1ZmZlciIsInN1YnRsZSIsImRpZ2VzdCIsImNyZWF0ZUhhc2giLCJmb3JFYWNoIiwidXBkYXRlIiwiY2tleSIsImltcG9ydEtleSIsImNyZWF0ZUhtYWMiLCJzaGEyNTZTeW5jIiwiaG1hY1NoYTI1NlN5bmMiLCJ0YWdQIiwidGFnSCIsImMiLCJjaGFyQ29kZUF0IiwiX0phY29iaWFuUG9pbnQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY29uZmlndXJhYmxlIiwidmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@noble/secp256k1/lib/esm/index.js\n");

/***/ })

};
;